# Progressive Web App Tutorial

## The Setup
Create a directory for the app and add js, css, and images subdirectories. It should look like this when you’re finished:

```
  /PWA-app
    /css
    /js
    /images
```

## Writing the App Interface

Create a file named index.html in your project root folder
```html
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Hello World</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
<body>
</body>
</html>
```

Next, create a file named style.css in the css folder and add a reference in then main.html file
```html
<head>
  ...
  <link rel="stylesheet" href="css/style.css">
<head>
```

Next, create a file named scripts.js in the js folder

## Cache

The Cache API is available in all modern browsers. It is exposed via the global caches property, so you can test for the presence of the API with a simple feature detection:

```javascript
const cacheAvailable = 'caches' in self;
```

The caches only store pairs of Request and Response objects, representing HTTP requests and responses, respectively. However, the requests and responses can contain any kind of data that can be transferred over HTTP.

### Open / create a cache

To open a cache, use the caches.open(name) method, passing the name of the cache as the single parameter. If the named cache does not exist, it is created. This method returns a Promise that resolves with the Cache object.

```javascript
const cache = await caches.open('my-cache');
```

#### Add items to a cache

There are three ways to add an item to a cache - add, addAll, and put. All three methods return a Promise.

####
add
First, there is cache.add(). It takes one parameter, either a Request or a URL (string). It makes a request to the network and stores the response in the cache. If the fetch fails, or if the status code of the response is not in the 200 range, then nothing is stored and the Promise rejects. Note that cross-origin requests not in CORS mode cannot be stored because they return a status of 0. Such requests can only be stored with put.

```javascript
// Retreive data.json from the server and store the response.
cache.add(new Request('/data.json'));

// Retreive data.json from the server and store the response.
cache.add('/data.json');
```

#### addAll

Works similarly to add(), but takes an array of Request objects or URLs (strings). This works similarly to calling cache.add for each individual request, except that the Promise rejects if any single request is not cached.

```javascript
const urls = ['/weather/today.json', '/weather/tomorrow.json'];
cache.addAll(urls);
```
In each of these cases, a new entry overwrites any matching existing entry

#### put

Allows you to store either a response from the network, or create and store your own Response. It takes two parameters. The first can either be a Request object or a URL (string). The second must be a Response, either from the network, or generated by your code.

```javascript
// Retreive data.json from the server and store the response.
cache.put('/data.json');

// Create a new entry for test.json and store the newly created response.
cache.put('/test.json', new Response('{"foo": "bar"}'));

// Retreive data.json from the 3rd party site and store the response.
cache.put('https://example.com/data.json');
```

The put() method is more permissive than either add() or addAll(), and will allow you to store non-CORS responses, or other responses where the status code of the response is not in the 200 range. It will overwrite any previous responses for the same request.

### Retrieving from a cache
To find an item in a cache, you can use the match method.

```javascript
const response = await cache.match(request);
console.log(request, response);
```

If request is a string the browser converts it to a Request by calling new Request(request). The function returns a Promise that resolves to a Response if a matching entry is found, or undefined otherwise.

To determine if two Requests match, the browser uses more than just the URL. Two requests are considered different if they have different query strings, Vary headers, or HTTP methods (GET, POST, PUT, etc.).

If more than one cached request matches then the one that was created first is returned. If you want to retrieve all matching responses, you can use cache.matchAll().

```javascript
const options = {
  ignoreSearch: true,
  ignoreMethod: true,
  ignoreVary: true
};

const responses = await cache.matchAll(request, options);
console.log(`There are ${responses.length} matching responses.`);
```

As a shortcut you can search over all caches at once by using caches.match() instead of calling cache.match() for each cache.

### Deleting an item

To delete an item from a cache:

```javascript
cache.delete(request);
```

Where request can be a Request or a URL string.

### Deleting a cache
To delete a cache, call caches.delete(name). This function returns a Promise that resolves to true if the cache existed and was deleted, or false otherwise.

## Add a Service Worker

> The location of the service worker is important! For security reasons, a service worker can only control the pages that are in its same directory or its subdirectories. This means that if you place the service worker file in a scripts directory it will only be able to interact with pages in the scripts directory or below.

Create a file named sw.js. Now we need to register the service worker, create a file named main.js in the js folder and enter the following code:

```js
window.onload = () => {
  'use strict';

  if ('serviceWorker' in navigator) {
    navigator.serviceWorker
    .register('./sw.js')
    .then(() => console.log('Service Worker Registered'));;
  }
}
```

Add the code to your app by including the script just before the closing </body> tag in index.html.

```
</div>
  <script src="js/main.js"></script>
</body>
```

### Cache Content

```js
var cacheName = 'hello-pwa';
var filesToCache = [
  '/',
  '/index.html',
  '/css/style.css',
  '/js/main.js'
];

/* Start the service worker and cache all of the app's content */
self.addEventListener('install', function(event) {
  event.waitUntil(
    caches.open(cacheName).then(function(cache) {
      return cache.addAll(filesToCache);
    })
  );
});

/* Serve cached content when offline */
self.addEventListener('fetch', function(event) {
  event.respondWith(
    caches.match(event.request).then(function(response) {
      return response || fetch(event.request);
    })
  );
});
```

The first lines of the script declares two variables: cacheName and filesToCache. cacheName is used to create an offline cache in the browser and give us access to it from Javascript. filesToCache is an array containing a list of all of the files that need to be cached. These files should be written in the form of URLs. Notice that the first one is simply “/”, the base URL. This is so the browser caches index.html even if the user doesn’t directly type in that file name.

Next, we add a function to install the service worker and create the browser cache using cacheName. Once the cache is created it adds all of the files listed in the filesToCache array. (Please note that while this code works for demonstration purposes it is not intended for production as it will stop if it fails to load even one of the files.)

Finally, we add a function to load from the cache, if the file not exists in the caches then load the file from the network.

> The caches.match method find in all caches asociated at the app scope.

```js
self.addEventListener('activate', (event) => {
  event.waitUntil(
    caches.keys().then((keyList) => {
      return Promise.all(keyList.map((key) => {
        if (key !== CACHE_NAME) {
          console.log('[ServiceWorker] Removing old cache', key);
          return caches.delete(key);
        }
      }));
    })
  );
});
```

We'll use the activate event to clean up any old data in our cache. This code ensures that your service worker updates its cache whenever any of the app shell files change. In order for this to work, you'd need to increment the CACHE_NAME variable at the top of your service worker file.

## Add a Manifest

The manifest is a json file that is used to specify how the app will look and behave on devices

Save a file named manifest.json in your root folder and add the following content:

```json
{
  "name": "Hello World",
  "short_name": "Hello",
  "lang": "en-US",
  "start_url": "/index.html",
  "display": "standalone",
  "background_color": "white",
  "theme_color": "white"
}
```

To add the manifest to your app, link to it inside the index.html head tag like this:
```html
<head>
...
<link rel="manifest" href="/manifest.json">
...
</head>
```

You should also declare the theme color to match the one set in your manifest by adding a meta tag inside the head:
```
<head>
...
<meta name="theme-color" content="white"/>
...
</head>
```
